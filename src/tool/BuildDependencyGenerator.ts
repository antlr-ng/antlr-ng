/*
 * Copyright (c) Mike Lischke. All rights reserved.
 * Licensed under the BSD 3-clause License. See License.txt in the project root for license information.
 */

import type { ITargetGenerator } from "src/codegen/ITargetGenerator.js";
import type { IGenerationOptions } from "src/config/config.js";
import { Constants } from "../Constants.js";
import { Tool } from "../Tool.js";
import { CodeGenerator } from "../codegen/CodeGenerator.js";
import { GrammarType } from "../support/GrammarType.js";
import { Grammar } from "./Grammar.js";

/**
 * Given a grammar file, show the dependencies on .tokens etc... Using ST, emit a simple "make compatible" list of
 * dependencies. For example, combined grammar T.g (no token import) generates:
 *
 *  	TParser.ts : T.g
 *  	T.tokens : T.g
 *  	TLexer.ts : T.g
 *
 * If we are using the listener pattern (-listener on the command line) then we add:
 *
 *    TListener.ts : T.g
 *    TBaseListener.ts : T.g
 *
 * If we are using the visitor pattern (-visitor on the command line) then we add:
 *
 *    TVisitor.ts : T.g
 *    TBaseVisitor.ts : T.g
 *
 * If "-lib libDir" is used on command-line with -depend and option tokenVocab=A in grammar, then include the path
 * like this:
 *
 *    T.g: libDir/A.tokens
 *
 * Pay attention to -o as well:
 *
 *    output-dir/TParser.ts : T.g
 *
 * So this output shows what the grammar depends on *and* what it generates.
 *
 * Operate on one grammar file at a time.  If given a list of .g on the command-line with -depend, just emit the
 * dependencies. The grammars may depend on each other, but the order doesn't matter.  Build tools, reading in this
 * output, will know how to organize it.
 */
export class BuildDependencyGenerator {
    protected tool: Tool;
    protected g: Grammar;
    protected generator: CodeGenerator;

    public constructor(tool: Tool, g: Grammar, private options: IGenerationOptions, targetGenerator: ITargetGenerator,
        private libDir?: string) {
        this.tool = tool;
        this.g = g;
        this.generator = new CodeGenerator(g, targetGenerator);
    }

    /**
     * @returns a list of URL objects that name files ANTLR will emit from T.g.
     */
    public getGeneratedFileList(): URL[] {
        const files = new Array<URL>();

        // Add generated recognizer, e.g., TParser.ts.
        if (this.generator.targetGenerator.needsDeclarationFile) {
            files.push(this.getOutputFile(this.generator.getRecognizerFileName(true)));
        }

        files.push(this.getOutputFile(this.generator.getRecognizerFileName(false)));

        // Add output vocab file, e.g. T.tokens. This is always generated to the base output directory, which will
        // be just `.` if there is no -o option.
        files.push(this.getOutputFile(this.generator.getVocabFileName()!));

        // Are we generating a declaration file (e.g. a C++ header file)?
        let declarationFileExtension = "";
        if (this.generator.targetGenerator.needsDeclarationFile) {
            declarationFileExtension = this.generator.targetGenerator.declarationFileExtension ?? "";
            const suffix = Grammar.getGrammarTypeToFileNameSuffix(this.g.type);
            const fileName = `${this.g.name}${suffix}${declarationFileExtension}`;
            files.push(this.getOutputFile(fileName));
        }

        if (this.g.isCombined()) {
            // Add autogenerated lexer, e.g., TLexer.ts TLexer.h TLexer.tokens.
            const suffix = Grammar.getGrammarTypeToFileNameSuffix(GrammarType.Lexer);
            const lexer = `${this.g.name}${suffix}${this.generator.targetGenerator.codeFileExtension}`;
            files.push(this.getOutputFile(lexer));

            const lexerTokens = this.g.name + suffix + Constants.VocabFileExtension;
            files.push(this.getOutputFile(lexerTokens));

            // TLexer.h
            if (declarationFileExtension) {
                const header = this.g.name + suffix + declarationFileExtension;
                files.push(this.getOutputFile(header));
            }
        }

        if (this.options.generateListener) {
            // Add generated listener, e.g., TListener.ts.
            if (this.generator.targetGenerator.needsDeclarationFile) {
                files.push(this.getOutputFile(this.generator.getListenerFileName(true)));
            }
            files.push(this.getOutputFile(this.generator.getListenerFileName(false)));

            // Add generated base listener; e.g., TBaseListener.ts.
            if (this.generator.targetGenerator.needsDeclarationFile) {
                files.push(this.getOutputFile(this.generator.getBaseListenerFileName(true)));
            }
            files.push(this.getOutputFile(this.generator.getBaseListenerFileName(false)));
        }

        if (this.options.generateVisitor) {
            // Add generated visitor, e.g. TVisitor.ts.
            if (this.generator.targetGenerator.needsDeclarationFile) {
                files.push(this.getOutputFile(this.generator.getVisitorFileName(true)));
            }
            files.push(this.getOutputFile(this.generator.getVisitorFileName(false)));

            // Add generated base visitor, e.g. TBaseVisitor.ts.
            if (this.generator.targetGenerator.needsDeclarationFile) {
                files.push(this.getOutputFile(this.generator.getBaseVisitorFileName(true)));
            }
            files.push(this.getOutputFile(this.generator.getBaseVisitorFileName(false)));
        }

        // Handle generated files for imported grammars.
        const imports = this.g.getAllImportedGrammars();
        for (const g of imports) {
            files.push(this.getOutputFile(g.fileName));
        }

        return files;
    }

    public getOutputFile(fileName: string): URL {
        let outputDir = this.tool.getOutputDirectory(this.g.fileName);
        if (outputDir === ".") {
            // Pay attention to -o then.
            outputDir = this.tool.getOutputDirectory(fileName);
        }

        if (outputDir === ".") {
            return new URL(fileName);
        }

        return new URL(fileName, outputDir);
    }

    /**
     * @returns a list of urls that name files antlr-ng will read to process T.g. This can be .tokens files if the
     * grammar uses the tokenVocab option as well as any imported grammar files.
     */
    public getDependenciesFileList(): string[] {
        // Find all the things other than imported grammars.
        const files = this.getNonImportDependenciesFileList();

        // Handle imported grammars.
        const imports = this.g.getAllImportedGrammars();
        const libDirectory = this.libDir ?? ".";
        for (const g of imports) {
            const fileName = this.groomQualifiedFileName(libDirectory, g.fileName);
            files.push(fileName);
        }

        return files;
    }

    /**
     * Return a list of File objects that name files antlr-ng will read to process T.g; This can only be .tokens files
     * and only if they use the tokenVocab option.
     *
     * @returns List of dependencies other than imported grammars
     */
    public getNonImportDependenciesFileList(): string[] {
        const files: string[] = [];

        // Handle token vocabulary loads.
        const tokenVocab = this.g.getOptionString("tokenVocab");
        if (tokenVocab !== undefined) {
            const fileName = tokenVocab + Constants.VocabFileExtension;
            const libDirectory = this.libDir ?? ".";
            if (libDirectory === ".") {
                files.push(fileName);
            } else {
                files.push(libDirectory + "/" + fileName);
            }
        }

        return files;
    }

    public getDependencies(): string {
        const inputFiles = this.getDependenciesFileList();
        const result: string[] = [];

        if (inputFiles.length > 0) {
            result.push(inputFiles.join(", "));
        }

        const outputFiles = this.getGeneratedFileList();
        outputFiles.forEach((file) => {
            result.push(`${file} : ${this.g.fileName}`);
        });

        return result.join("\n");
    }

    public getGenerator(): CodeGenerator {
        return this.generator;
    }

    private groomQualifiedFileName(outputDir: string, fileName: string): string {
        if (outputDir === ".") {
            return fileName;
        } else if (outputDir.includes(" ")) { // Has spaces?
            const escSpaces = outputDir.replaceAll(" ", "\\ ");

            return escSpaces + "/" + fileName;
        } else {
            return outputDir + "/" + fileName;
        }
    }
}
