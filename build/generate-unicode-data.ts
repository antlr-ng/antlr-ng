/*
 * Copyright (c) Mike Lischke. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */

/**
 * This class extracts necessary Unicode data from the Unicode database and generates a TypeScript file
 * with that data. The file is then used by the runtime to support Unicode properties and categories.
 */

/// <reference path="types.d.ts" />

import * as fs from "fs/promises";
import { join, dirname } from "path";

import { IntervalSet } from "antlr4ng";

interface IDataFileContent {
    default: IUnicodeRange[];
}

const packageName = "@unicode/unicode-15.1.0";
const sourceURL = join(dirname(import.meta.url), `../node_modules/${packageName}`).substring("file:".length);

const numberToHex = (value: number): string => {
    return value.toString(16).toUpperCase();
};

/**
 * Imports the given unicode data file and creates an interval set from it, by collecting all contained ranges.
 *
 * @param file The file to import.
 *
 * @returns An interval set containing all ranges from the imported file.
 */
const intervalSetFromImport = async (file: string): Promise<IntervalSet> => {
    const content = await import(file) as IDataFileContent;
    const set = new IntervalSet();
    for (const range of content.default) {
        set.addRange(range.begin, range.end);
    }

    return set;
};

// Generate the Unicode data file.
const targetPath = join(dirname(import.meta.url), "../src/generated/UnicodeData.ts").substring("file:".length);
await fs.writeFile(targetPath, "// Data generated by build/generate-unicode-data.ts. Do not edit.\n\n");
await fs.appendFile(targetPath, `import { IntervalSet } from "antlr4ng";\n\n`);
await fs.appendFile(targetPath, `let set: IntervalSet;\n\n`);

const generateMap = async (basePath: string): Promise<void> => {
    // Convert snake case to camel case.
    const camelName = basePath.toLowerCase().replace(/([-_][a-z])/g, (group): string => {
        return group
            .toUpperCase()
            .replace("-", "")
            .replace("_", "");
    });

    await fs.appendFile(targetPath, `export const ${camelName} = new Map<string, IntervalSet>();\n`);

    // Enumerate all folders in the base path.
    const folderURL = join(sourceURL, basePath);
    const elements = await fs.readdir(folderURL);
    for (const element of elements) {
        // Is the element a folder?
        const target = join(folderURL, element);
        const s = await fs.stat(target);
        if (!s.isDirectory()) {
            continue;
        }

        await fs.appendFile(targetPath, `set = new IntervalSet();\n`);
        const set = await intervalSetFromImport(`${target}/ranges.js`);
        let counter = 0;
        for (const range of set) {
            await fs.appendFile(targetPath, `set.addRange(0x${numberToHex(range.start)}, ` +
                `0x${numberToHex(range.stop)}); `);
            ++counter;
            if (counter === 5) {
                await fs.appendFile(targetPath, "\n");
                counter = 0;
            }
        }

        await fs.appendFile(targetPath, `\n${camelName}.set("${element}", set);\n\n`);
    }
};

await generateMap("Bidi_Class");
await generateMap("Binary_Property");
await generateMap("Block");
await generateMap("General_Category");
await generateMap("Line_Break");
await generateMap("Script");
await generateMap("Script_Extensions");
await generateMap("Word_Break");
