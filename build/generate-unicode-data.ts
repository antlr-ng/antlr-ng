/*
 * Copyright (c) Mike Lischke. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */

/**
 * This class extracts necessary Unicode data from the Unicode database and generates a TypeScript file
 * with that data. The file is then used by the runtime to support Unicode properties and categories.
 */

/// <reference path="types.d.ts" />

import * as fs from "fs/promises";
import { join, dirname } from "path";

import { IntervalSet } from "antlr4ng";

const aliases = new Map<string, Map<string, string>>([
    ["", new Map<string, string>([
        // General properties.
        ["uppercase_letter", "lu"],
        ["lowercase_letter", "ll"],
        ["titlecase_letter", "lt"],
        ["cased_letter", "lc"],
        ["modifier_letter", "lm"],
        ["other_letter", "lo"],
        ["letter", "l"],
        ["nonspacing_mark", "mn"],
        ["spacing_mark", "mc"],
        ["enclosing_mark", "me"],
        ["mark", "m"],
        ["decimal_number", "nd"],
        ["letter_number", "nl"],
        ["other_number", "no"],
        ["number", "n"],
        ["connector_punctuation", "pc"],
        ["dash_punctuation", "pd"],
        ["open_punctuation", "ps"],
        ["close_punctuation", "pe"],
        ["initial_punctuation", "pi"],
        ["final_punctuation", "pf"],
        ["other_punctuation", "po"],
        ["punctuation", "p"],
        ["math_symbol", "sm"],
        ["currency_symbol", "sc"],
        ["modifier_symbol", "sk"],
        ["other_symbol", "so"],
        ["symbol", "s"],
        ["space_separator", "zs"],
        ["line_separator", "zl"],
        ["paragraph_separator", "zp"],
        ["separator", "z"],
        ["control", "cc"],
        ["format", "cf"],
        ["surrogate", "cs"],
        ["private_use", "co"],
        ["unassigned", "cn"],
        ["other", "c"],

        // More values are loaded from the PropertyAliases.txt file.
    ])],
    ["bc", new Map<string, string>([ // BIDI classes.
        ["left_to_right", "l"],
        ["right_to_left", "r"],
        ["arabic_letter", "al"],
        ["european_number", "en"],
        ["european_separator", "es"],
        ["european_terminator", "et"],
        ["arabic_number", "an"],
        ["common_separator", "cs"],
        ["nonspacing_mark", "nsm"],
        ["boundary_neutral", "bn"],
        ["paragraph_separator", "b"],
        ["segment_separator", "s"],
        ["white_space", "ws"],
        ["other_neutral", "on"],
        ["left_to_right_embedding", "lre"],
        ["left_to_right_override", "lro"],
        ["right_to_left_embedding", "rle"],
        ["right_to_left_override", "rlo"],
        ["pop_directional_format", "pdf"],
        ["left_to_right_isolate", "lri"],
        ["right_to_left_isolate", "rli"],
        ["first_strong_isolate", "fsi"],
        ["pop_directional_isolate", "pdi"],
    ])],
]);

interface IUnicodeRange {
    begin: number;
    end: number;
    length: number;
}

interface IDataFileContent {
    default: IUnicodeRange[];
}

const packageName = "@unicode/unicode-15.1.0";
const sourceURL = join(dirname(import.meta.url), `../node_modules/${packageName}`).substring("file:".length);

const numberToHex = (value: number): string => {
    return value.toString(16).toUpperCase();
};

/**
 * Imports the given unicode data file and creates an interval set from it, by collecting all contained ranges.
 *
 * @param file The file to import.
 *
 * @returns An interval set containing all ranges from the imported file.
 */
const intervalSetFromImport = async (file: string): Promise<IntervalSet> => {
    const content = await import(file) as IDataFileContent;
    const set = new IntervalSet();
    for (const range of content.default) {
        set.addRange(range.begin, range.end);
    }

    return set;
};

// Generate the Unicode data file.
const targetPath = join(dirname(import.meta.url), "../src/generated/UnicodeData.ts").substring("file:".length);
await fs.writeFile(targetPath, "// Data generated by build/generate-unicode-data.ts. Do not edit.\n\n");
await fs.appendFile(targetPath, `import { IntervalSet } from "antlr4ng";\n\n`);
await fs.appendFile(targetPath, `/** A mapping from a Unicode property type to a set of code points. */\n`);
await fs.appendFile(targetPath, `export const propertyCodePointRanges = new Map<string, IntervalSet>();\n\n`);
await fs.appendFile(targetPath, `let set: IntervalSet;\n\n`);

const generateMap = async (basePath: string): Promise<void> => {
    console.log(`Generating map for ${basePath}...`);

    const mainList = aliases.get("");
    const abbr = mainList?.get(basePath.toLocaleLowerCase());

    // Enumerate all folders in the base path.
    const folderURL = join(sourceURL, basePath);
    const elements = await fs.readdir(folderURL);
    for (const element of elements) {
        // Is the element a folder?
        const target = join(folderURL, element);
        const s = await fs.stat(target);
        if (!s.isDirectory()) {
            continue;
        }

        await fs.appendFile(targetPath, `set = new IntervalSet();\n`);
        const set = await intervalSetFromImport(`${target}/ranges.js`);
        let counter = 0;
        for (const range of set) {
            await fs.appendFile(targetPath, `set.addRange(0x${numberToHex(range.start)}, ` +
                `0x${numberToHex(range.stop)}); `);
            ++counter;
            if (counter === 5) {
                await fs.appendFile(targetPath, "\n");
                counter = 0;
            }
        }

        if (counter > 0) {
            await fs.appendFile(targetPath, "\n");
        }

        const elementName = element.toLocaleLowerCase();
        if (abbr) {
            // Enumerated values.
            const list = aliases.get(abbr);
            const abbreviated = list?.get(elementName);
            await fs.appendFile(targetPath,
                `propertyCodePointRanges.set("${abbr}=${abbreviated ?? elementName}", set);\n\n`);
        } else {
            // Catalog properties, enumerated property names, general categories and binary properties.
            const abbreviated = mainList?.get(elementName);
            await fs.appendFile(targetPath,
                `propertyCodePointRanges.set("${abbreviated ?? elementName}", set);\n\n`);
        }
    }
};

let content = await fs.readFile(join(dirname(import.meta.url).substring("file:".length), "PropertyAliases.txt"),
    "utf8");
const lines = content.split("\n");
const list = aliases.get("");
for (const line of lines) {
    const parts = line.split(";");
    if (parts.length < 2) {
        continue;
    }

    const key = parts[1].trim().toLowerCase();
    const value = parts[0].trim().toLowerCase();
    if (list) {
        list.set(key, value);
    }
}

await generateMap("Bidi_Class");
await generateMap("Binary_Property");
await generateMap("Block");
await generateMap("General_Category");
await generateMap("Line_Break");
await generateMap("Script");
await generateMap("Script_Extensions");
await generateMap("Word_Break");

// Finally add the aliases. These were taken from the Java Unicode data generator (which uses ICU for that).
content = await fs.readFile(join(dirname(import.meta.url).substring("file:".length), "aliases.json"), "utf8");
await fs.appendFile(targetPath, `export const propertyAliases = new Map<string, string>(${content});\n`);
