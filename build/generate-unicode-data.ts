/*
 * Copyright (c) Mike Lischke. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */

/**
 * This class extracts necessary Unicode data from the Unicode database and generates a TypeScript file
 * with that data. The file is then used by the runtime to support Unicode properties and categories.
 */

import { createWriteStream } from "fs";
import { readdir, readFile, stat } from "fs/promises";
import { join, dirname } from "path";

import { IntervalSet } from "antlr4ng";

const aliases = new Map<string, Map<string, string>>([
    ["", new Map<string, string>([
        // General properties.
        ["uppercase_letter", "lu"],
        ["lowercase_letter", "ll"],
        ["titlecase_letter", "lt"],
        ["cased_letter", "lc"],
        ["modifier_letter", "lm"],
        ["other_letter", "lo"],
        ["letter", "l"],
        ["nonspacing_mark", "mn"],
        ["spacing_mark", "mc"],
        ["enclosing_mark", "me"],
        ["mark", "m"],
        ["decimal_number", "nd"],
        ["letter_number", "nl"],
        ["other_number", "no"],
        ["number", "n"],
        ["connector_punctuation", "pc"],
        ["dash_punctuation", "pd"],
        ["open_punctuation", "ps"],
        ["close_punctuation", "pe"],
        ["initial_punctuation", "pi"],
        ["final_punctuation", "pf"],
        ["other_punctuation", "po"],
        ["punctuation", "p"],
        ["math_symbol", "sm"],
        ["currency_symbol", "sc"],
        ["modifier_symbol", "sk"],
        ["other_symbol", "so"],
        ["symbol", "s"],
        ["space_separator", "zs"],
        ["line_separator", "zl"],
        ["paragraph_separator", "zp"],
        ["separator", "z"],
        ["control", "cc"],
        ["format", "cf"],
        ["surrogate", "cs"],
        ["private_use", "co"],
        ["unassigned", "cn"],
        ["other", "c"],

        // More values are loaded from the PropertyAliases.txt file.
    ])],
    ["bc", new Map<string, string>([ // BIDI classes.
        ["left_to_right", "l"],
        ["right_to_left", "r"],
        ["arabic_letter", "al"],
        ["european_number", "en"],
        ["european_separator", "es"],
        ["european_terminator", "et"],
        ["arabic_number", "an"],
        ["common_separator", "cs"],
        ["nonspacing_mark", "nsm"],
        ["boundary_neutral", "bn"],
        ["paragraph_separator", "b"],
        ["segment_separator", "s"],
        ["white_space", "ws"],
        ["other_neutral", "on"],
        ["left_to_right_embedding", "lre"],
        ["left_to_right_override", "lro"],
        ["right_to_left_embedding", "rle"],
        ["right_to_left_override", "rlo"],
        ["pop_directional_format", "pdf"],
        ["left_to_right_isolate", "lri"],
        ["right_to_left_isolate", "rli"],
        ["first_strong_isolate", "fsi"],
        ["pop_directional_isolate", "pdi"],
    ])],
]);

interface IUnicodeRange {
    begin: number;
    end: number;
    length: number;
}

interface IDataFileContent {
    default: IUnicodeRange[];
}

const packageName = "@unicode/unicode-15.1.0";
const sourceURL = join(dirname(import.meta.url), `../node_modules/${packageName}`).substring("file:".length);

const numberToHex = (value: number): string => {
    return value.toString(16).toUpperCase();
};

/**
 * Imports the given unicode data file and creates an interval set from it, by collecting all contained ranges.
 *
 * @param file The file to import.
 *
 * @returns An interval set containing all ranges from the imported file.
 */
const intervalSetFromImport = async (file: string): Promise<IntervalSet> => {
    const content = await import(file) as IDataFileContent;
    const set = new IntervalSet();
    for (const range of content.default) {
        set.addRange(range.begin, range.end);
    }

    return set;
};

// Generate the Unicode data file.
const targetPath = join(dirname(import.meta.url), "../src/generated/UnicodeData.ts").substring("file:".length);
const writer = createWriteStream(targetPath);

writer.write("// Data generated by build/generate-unicode-data.ts. Do not edit.\n\n");
writer.write(`import { IntervalSet } from "antlr4ng";\n\n`);
writer.write(`/** A mapping from a Unicode property type to a set of code points. */\n`);
writer.write(`export const propertyCodePointRanges = new Map<string, IntervalSet>();\n\n`);

const generateMap = async (basePath: string): Promise<void> => {
    console.log(`Generating map for ${basePath}...`);

    const mainList = aliases.get("");
    const abbr = mainList?.get(basePath.toLocaleLowerCase());

    // Enumerate all folders in the base path.
    const folderURL = join(sourceURL, basePath);
    const elements = await readdir(folderURL);
    for (const element of elements) {
        // Is the element a folder?
        const target = join(folderURL, element);
        const s = await stat(target);
        if (!s.isDirectory()) {
            continue;
        }

        writer.write(`set = new IntervalSet();\n`);
        const set = await intervalSetFromImport(`${target}/ranges.js`);
        let counter = 0;
        for (const range of set) {
            writer.write(`set.addRange(0x${numberToHex(range.start)}, ` +
                `0x${numberToHex(range.stop)}); `);
            ++counter;
            if (counter === 5) {
                writer.write("\n");
                counter = 0;
            }
        }

        if (counter > 0) {
            writer.write("\n");
        }

        const elementName = element.toLocaleLowerCase();
        if (abbr) {
            // Enumerated values.
            const list = aliases.get(abbr);
            const abbreviated = list?.get(elementName);
            writer.write(`propertyCodePointRanges.set("${abbr}=${abbreviated ?? elementName}", set);\n\n`);
        } else {
            // Catalog properties, enumerated property names, general categories and binary properties.
            const abbreviated = mainList?.get(elementName);
            writer.write(`propertyCodePointRanges.set("${abbreviated ?? elementName}", set);\n\n`);
        }
    }
};

const generateBlocksMap = async (): Promise<void> => {
    console.log(`Collecting Unicode blocks data...`);

    const folderURL = join(sourceURL, "Block");
    const elements = await readdir(folderURL);

    const ranges = new Map<string, string>();
    const nameMap = new Map<string, string>();

    writer.write(`export class UnicodeBlockConstants {\n`);
    for (let i = 0; i < elements.length; ++i) {
        const element = elements[i];

        const target = join(folderURL, element);
        const s = await stat(target);
        if (!s.isDirectory() || element === "undefined") {
            continue;
        }

        writer.write(`    public static ${element.toUpperCase()} = ${i};\n`);

        // Block ranges always contain only one entry.
        const content = await import(`${target}/ranges.js`) as IDataFileContent;

        ranges.set(`UnicodeBlockConstants.${element.toUpperCase()}`,
            `[0x${numberToHex(content.default[0].begin)}, ` +
            `0x${numberToHex(content.default[0].end)}]`);
        nameMap.set(element, `UnicodeBlockConstants.${element.toUpperCase()}`);
    }

    // Write collected maps.
    writer.write(`\n    public static readonly ranges = new Map<number, [number, number]>([\n`);
    for (const [key, value] of ranges) {
        writer.write(`        [${key}, ${value}], \n`);
    }
    writer.write(`    ]); \n`);

    writer.write(`\n    public static readonly names = new Map<string, number>([\n`);
    for (const [key, value] of nameMap) {
        writer.write(`        ["${key.replace(/_/g, "").toLowerCase()}", ${value}], \n`);
    }

    writer.write("    ]);\n\n}\n\n");
};

let content = await readFile(join(dirname(import.meta.url).substring("file:".length), "PropertyAliases.txt"),
    "utf8");
const lines = content.split("\n");
const list = aliases.get("");
for (const line of lines) {
    const parts = line.split(";");
    if (parts.length < 2) {
        continue;
    }

    const key = parts[1].trim().toLowerCase();
    const value = parts[0].trim().toLowerCase();
    if (list) {
        list.set(key, value);
    }
}

await generateBlocksMap();

writer.write(`let set: IntervalSet; \n\n`);

await generateMap("Bidi_Class");
await generateMap("Binary_Property");
await generateMap("Block");
await generateMap("General_Category");
await generateMap("Line_Break");
await generateMap("Script");
await generateMap("Script_Extensions");
await generateMap("Word_Break");

// Finally add the aliases. These were taken from the Java Unicode data generator (which uses ICU for that).
content = await readFile(join(dirname(import.meta.url).substring("file:".length), "aliases.json"), "utf8");
writer.write(`export const propertyAliases = new Map<string, string>(${content}); \n`);

writer.close();

console.log("\nUnicode data generation completed.\n");
