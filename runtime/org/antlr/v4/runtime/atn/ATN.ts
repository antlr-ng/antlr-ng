/* java2ts: keep */

/*
 * Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

import { java } from "../../../../../../lib/java/java";
import { ATNState } from "./ATNState";
import { ATNType } from "./ATNType";
import { DecisionState } from "./DecisionState";
import { LexerAction } from "./LexerAction";
import { LL1Analyzer } from "./LL1Analyzer";
import { RuleStartState } from "./RuleStartState";
import { RuleStopState } from "./RuleStopState";
import { RuleTransition } from "./RuleTransition";
import { TokensStartState } from "./TokensStartState";
import { RuleContext } from "../RuleContext";
import { Token } from "../Token";
import { IntervalSet } from "../misc/IntervalSet";

import { JavaObject } from "../../../../../../lib/java/lang/Object";
import { S } from "../../../../../../lib/templates";

export class ATN extends JavaObject {
    // eslint-disable-next-line @typescript-eslint/naming-convention
    public static readonly INVALID_ALT_NUMBER: number = 0;

    public readonly states = new java.util.ArrayList<ATNState | null>();

    /**
     * Each subrule/rule is a decision point and we must track them so we
     *  can go back later and build DFA predictors for them.  This includes
     *  all the rules, subrules, optional blocks, ()+, ()* etc...
     */
    public readonly decisionToState = new java.util.ArrayList<DecisionState>();

    /**
     * Maps from rule index to starting state number.
     */
    public ruleToStartState!: RuleStartState[];

    /**
     * Maps from rule index to stop state number.
     */
    public ruleToStopState!: RuleStopState[];

    public readonly modeNameToStartState = new java.util.LinkedHashMap<java.lang.String, TokensStartState>();

    /**
     * The type of the ATN.
     */
    public readonly grammarType: ATNType;

    /**
     * The maximum value for any symbol recognized by a transition in the ATN.
     */
    public readonly maxTokenType: number;

    /**
     * For lexer ATNs, this maps the rule index to the resulting token type.
     * For parser ATNs, this maps the rule index to the generated bypass token
     * type if the
     * {@link ATNDeserializationOptions#isGenerateRuleBypassTransitions}
     * deserialization option was specified; otherwise, this is {@code null}.
     */
    public ruleToTokenType!: Int32Array;

    /**
     * For lexer ATNs, this is an array of {@link LexerAction} objects which may
     * be referenced by action transitions in the ATN.
     */
    public lexerActions?: LexerAction[];

    public readonly modeToStartState = new java.util.ArrayList<TokensStartState>();

    /**
     * Used for runtime deserialization of ATNs from strings
     *
     * @param grammarType tbd
     * @param maxTokenType tbd
     */
    public constructor(grammarType: ATNType | null, maxTokenType: number) {
        super();

        if (grammarType === null) {
            throw new java.lang.NullPointerException();
        }

        this.grammarType = grammarType;
        this.maxTokenType = maxTokenType;
    }

    /**
     * Compute the set of valid tokens that can occur starting in state {@code s}.
     *  If {@code ctx} is null, the set of tokens will not include what can follow
     *  the rule surrounding {@code s}. In other words, the set will be
     *  restricted to tokens reachable staying within {@code s}'s rule.
     *
     * @param s tbd
     * @param ctx tbd
     *
     * @returns tbd
     */
    public nextTokens(s: ATNState, ctx?: RuleContext | null): IntervalSet {
        if (ctx === undefined) {
            if (s.nextTokenWithinRule !== null) {
                return s.nextTokenWithinRule;
            }

            s.nextTokenWithinRule = this.nextTokens(s, null);
            s.nextTokenWithinRule?.setReadonly(true);

            return s.nextTokenWithinRule;
        } else {
            const anal = new LL1Analyzer(this);
            const next = anal.LOOK(s, ctx);

            return next;
        }
    }

    public addState = (state: ATNState | null): void => {
        if (state !== null) {
            state.atn = this;
            state.stateNumber = this.states.size();
        }

        this.states.add(state);
    };

    public removeState = (state: ATNState): void => {
        this.states.set(state.stateNumber, null); // just free mem, don't shift states in list
    };

    public defineDecisionState = (s: DecisionState): number => {
        this.decisionToState.add(s);
        s.decision = this.decisionToState.size() - 1;

        return s.decision;
    };

    public getDecisionState = (decision: number): DecisionState | null => {
        if (!(this.decisionToState.isEmpty())) {
            return this.decisionToState.get(decision);
        }

        return null;
    };

    public getNumberOfDecisions = (): number => {
        return this.decisionToState.size();
    };

    /**
     * Computes the set of input symbols which could follow ATN state number
     * {@code stateNumber} in the specified full {@code context}. This method
     * considers the complete parser context, but does not evaluate semantic
     * predicates (i.e. all predicates encountered during the calculation are
     * assumed true). If a path in the ATN exists from the starting state to the
     * {@link RuleStopState} of the outermost context without matching any
     * symbols, {@link Token#EOF} is added to the returned set.
     *
     * <p>If {@code context} is {@code null}, it is treated as {@link ParserRuleContext#EMPTY}.</p>
     *
     * Note that this does NOT give you the set of all tokens that could
     * appear at a given token position in the input phrase.  In other words,
     * it does not answer:
     *
     *   "Given a specific partial input phrase, return the set of all tokens
     *    that can follow the last token in the input phrase."
     *
     * The big difference is that with just the input, the parser could
     * land right in the middle of a lookahead decision. Getting
     * all *possible* tokens given a partial input stream is a separate
     * computation. See https://github.com/antlr/antlr4/issues/1428
     *
     * For this function, we are specifying an ATN state and call stack to compute
     * what token(s) can come next and specifically: outside of a lookahead decision.
     * That is what you want for error reporting and recovery upon parse error.
     *
     * @param stateNumber the ATN state number
     * @param context the full parse context
     *
     * @returns The set of potentially valid input symbols which could follow the
     * specified state in the specified context.
     * @throws IllegalArgumentException if the ATN does not contain a state with
     * number {@code stateNumber}
     */
    public getExpectedTokens = (stateNumber: number, context: RuleContext | null): IntervalSet | null => {
        if (stateNumber < 0 || stateNumber >= this.states.size()) {
            throw new java.lang.IllegalArgumentException(S`Invalid state number.`);
        }

        let ctx: RuleContext | null = context;
        const s = this.states.get(stateNumber);
        if (s === null) {
            return IntervalSet.of(-1);
        }

        let following = this.nextTokens(s);
        if (!following || !(following.contains(Token.EPSILON))) {
            return following;
        }

        const expected = new IntervalSet();
        expected.addAll(following);
        expected.remove(Token.EPSILON);
        while (ctx !== null && ctx.invokingState >= 0 && following.contains(Token.EPSILON)) {
            const invokingState = this.states.get(ctx.invokingState);
            if (invokingState) {
                const rt = invokingState.transition(0) as RuleTransition;
                following = this.nextTokens(rt.followState);
                if (!following) {
                    break;
                }

                expected.addAll(following);
                expected.remove(Token.EPSILON);
                ctx = ctx.parent ?? null;
            }
        }

        if (following?.contains(Token.EPSILON)) {
            expected.add(Token.EOF);
        }

        return expected;
    };
}
